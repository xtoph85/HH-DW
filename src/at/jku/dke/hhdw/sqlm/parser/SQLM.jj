/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. SQLM.jj */
/*@egen*/options
{
  JDK_VERSION = "1.5";
  STATIC = true;
               
                                                                                      
                            // all classes are prefixed with "AST"
  IGNORE_CASE = true;                                   
                          
}

PARSER_BEGIN(SQLMParser)

package at.jku.dke.sqlm.parser;

public class SQLMParser/*@bgen(jjtree)*/implements SQLMParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTSQLMParserState jjtree = new JJTSQLMParserState();

/*@egen*/
  public static void main(String args [])
  {
    System.out.println("Reading from standard input...");
    System.out.print("Enter an SQL(M) block:");
    
    new SQLMParser(System.in);
    
    try
    {
      ASTSQLMDocument n = SQLMParser.Start();
      
      n.dump("");
      
      System.out.println("Thank you.");
    }
    catch (Exception e)
    {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
    }
  }
}

PARSER_END(SQLMParser)


SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
}

SPECIAL_TOKEN:
{
   < LINE_COMMENT: "--"(~["\r","\n"])*>
|  < MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}


TOKEN : /* KEYWORDS */
{
  < K_BEGIN : "BEGIN" >
| < K_END : "END" >
| < K_CREATE : "CREATE">
| < K_K_ALTER : "ALTER" >
| < K_DROP : "DROP" >
| < K_UPDATE : "UPDATE" >
| < K_DIMENSION : "DIMENSION" >
| < K_HIERARCHY : "HIERARCHY" >
| < K_OBJECT : "OBJECT" >
| < K_OBJECTS : "OBJECTS" >
| < K_MULTILEVEL : "MULTILEVEL" >
| < K_CUBE : "CUBE" >
| < K_FACT : "FACT" >
| < K_IN : "IN" >
| < K_AT : "AT" >
| < K_LEVEL : "LEVEL" >
| < K_UNDER : "UNDER" >
| < K_CHILD : "CHILD" >
| < K_OF : "OF" >
| < K_NULL : "NULL" >
| < K_DIMENSIONS : "DIMENSIONS" >
| < K_BETWEEN : "BETWEEN" >
| < K_CONNECTION : "CONNECTION" >
| < K_ADD : "ADD" >
| < K_ATTRIBUTE : "ATTRIBUTE" >
| < K_MEASURE : "MEASURE" >
| < K_SET : "SET" >
| < K_DEFAULT : "DEFAULT" >
| < K_SHARED : "SHARED" >
| < K_SUM : "SUM" >
| < K_AVG : "AVG" >
| < K_MIN : "MIN" >
| < K_MAX : "MAX" >
| < K_SET_UNION : "SET_UNION" >
| < K_BULK : "BULK" >
| < K_SELECT : "SELECT" >
| < K_FROM : "FROM" >
| < K_WHERE : "WHERE" >
| < K_LIKE : "LIKE" >
| < K_DICE : "DICE" >
| < K_ROLLUP : "ROLLUP" >
| < K_CONVERT : "CONVERT" >
| < K_TO : "TO" >
| < K_CONVERT_TO : "CONVERT_TO">
| < K_AND : "AND" >
| < K_OR : "OR" >
| < K_VARCHAR2 : "VARCHAR2" >
| < K_NUMBER : "NUMBER" >
| < K_DISTINCT : "DISTINCT" >
| < K_ANY : "ANY" >
| < K_ALL : "ALL" >
| < K_START : "START" >
| < K_CONNECT : "CONNECT" >
| < K_WITH : "WITH" >
| < K_BY : "BY" >
| < K_GROUP : "GROUP" >
| < K_ORDER : "ORDER" >
| < K_HAVING : "HAVING" >
| < K_MINUS : "MINUS" >
| < K_INTERSECT : "INTERSECT" >
| < K_UNION : "UNION" >
| < K_ASC : "ASC" >
| < K_DESC : "DESC" >
| < K_FOR : "FOR" >
| < K_NOT : "NOT" >
| < K_EXISTS : "EXISTS" >
| < K_PRIOR : "PRIOR" >
| < K_IS : "IS" >
| < K_JOIN : "JOIN" >
| < K_ON : "ON" >
| < K_USING : "USING" >
| < K_FULL : "FULL" >
| < K_LEFT : "LEFT" >
| < K_RIGHT : "RIGHT" >
| < K_INNER : "INNER" >
| < K_OUTER : "OUTER" >
}

TOKEN : /* Numeric Constants */
{
	< S_NUMBER : < FLOAT >
	    | < FLOAT > ( ["e","E"] ([ "-","+"])? < FLOAT > )?
    	>
  | 	< #FLOAT: < INTEGER >
	    | <INTEGER> ( "." < INTEGER > )?
	    | "." < INTEGER >
    	>
  | 	< #INTEGER: ( < DIGIT > )+ >
  | 	< #DIGIT: ["0" - "9"] >
}

TOKEN:
{
	< S_IDENTIFIER: ( < LETTER > )+ ( < DIGIT > | < LETTER > |< SPECIAL_CHARS >)* >
| 	< #LETTER: ["a"-"z", "A"-"Z"] >
|   < #SPECIAL_CHARS: "$" | "_">
|   < S_BIND: ":" < S_IDENTIFIER > ("." < S_IDENTIFIER >)? >
|   < S_CHAR_LITERAL: "'" (~["'"])* "'" ("'" (~["'"])* "'")*>
|   < S_QUOTED_IDENTIFIER: "\"" (~["\n","\r","\""])* "\"" >
}

/**
 * An M-SQL document consists of multiple M-SQL blocks.
 * The MSQLDocument class is the root of the AST.
 */
ASTSQLMDocument Start()               :
{/*@bgen(jjtree) SQLMDocument */
  ASTSQLMDocument jjtn000 = new ASTSQLMDocument(JJTSQLMDOCUMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SQLMDocument */
  try {
/*@egen*/
  (
    Statement() //";"
  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/* data types */

/**
 * The data length indicates the number of bytes of a variable.
 */
void DataLength()             :
{/*@bgen(jjtree) DataLength */
  ASTDataLength jjtn000 = new ASTDataLength(JJTDATALENGTH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) DataLength */
  try {
/*@egen*/
  t = < S_NUMBER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
 * The data scale is the number of digits after the floating point.
 */
void DataScale()            :
{/*@bgen(jjtree) DataScale */
  ASTDataScale jjtn000 = new ASTDataScale(JJTDATASCALE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) DataScale */
  try {
/*@egen*/
  t = < S_NUMBER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
 * Common SQL data types are available in M-SQL as well.
 * There is no DataType node class. Instead, the concrete
 * data types are stored as a node in the AST.
 * TODO: Future implementations of M-SQL should also
 *       support user-defined types.
 */
void DataType() :
{}
{
  (
    Varchar2Type()
  | NumberType()
  | UserDefinedType()
  )
}

void UserDefinedType()                  :
{/*@bgen(jjtree) UserDefinedType */
  ASTUserDefinedType jjtn000 = new ASTUserDefinedType(JJTUSERDEFINEDTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) UserDefinedType */
  try {
/*@egen*/
  t = < S_IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
 * Varchar2Type represents the SQL VARCHAR2 data type.
 */
void Varchar2Type()               :
{/*@bgen(jjtree) Varchar2Type */
  ASTVarchar2Type jjtn000 = new ASTVarchar2Type(JJTVARCHAR2TYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) Varchar2Type */
  try {
/*@egen*/
  t = "VARCHAR2" "(" DataLength() ")"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
 * NumberType represents the SQL VARCHAR2 data type.
 */
void NumberType()             :
{/*@bgen(jjtree) NumberType */
  ASTNumberType jjtn000 = new ASTNumberType(JJTNUMBERTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) NumberType */
        try {
/*@egen*/
	t = "NUMBER" ( "(" DataLength() ("," DataScale())? ")" )?/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
    jjtn000.jjtSetValue(t.image);
  }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


/* values */

/**
 * Values are organized into String and number values.
 * These two generic types are used for all variations in SQL.
 */
void Value() :
{}
{
  (
    StringValue()
  | NumberValue()
  | LOOKAHEAD(2)(MultilevelObjectQualifiedID())
  | LOOKAHEAD(2)(ObjectCollectionConstructor())
  | LOOKAHEAD(2)(ObjectConstructor())
  )
}

void ObjectCollectionConstructor()                             :
{/*@bgen(jjtree) ObjectCollectionConstructor */
  ASTObjectCollectionConstructor jjtn000 = new ASTObjectCollectionConstructor(JJTOBJECTCOLLECTIONCONSTRUCTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
  StringBuffer sb = new StringBuffer();
}
{/*@bgen(jjtree) ObjectCollectionConstructor */
  try {
/*@egen*/
  {
    // remember current token
    t = getToken(0);
  }
  UserDefinedType() "(" ObjectConstructorList() ")"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    // get the string value of this production rule
    // future implementations may do more with this type
    while(t != null)
    {
      sb.append(t.image);
      t = t.next;
    }

    // this string can be used as-is for the translation into PL/SQL
	jjtn000.jjtSetValue(sb.toString());
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ObjectConstructorList()                       :
{/*@bgen(jjtree) ObjectConstructorList */
  ASTObjectConstructorList jjtn000 = new ASTObjectConstructorList(JJTOBJECTCONSTRUCTORLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ObjectConstructorList */
  try {
/*@egen*/
  ObjectConstructor() ("," ObjectConstructor())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ObjectConstructor()                   :
{/*@bgen(jjtree) ObjectConstructor */
  ASTObjectConstructor jjtn000 = new ASTObjectConstructor(JJTOBJECTCONSTRUCTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
  StringBuffer sb = new StringBuffer();
}
{/*@bgen(jjtree) ObjectConstructor */
  try {
/*@egen*/
  {
    // remember current token
    t = getToken(0);
  }
  UserDefinedType() "(" ObjectAttributeList() ")"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    // get the string value of this production rule
    // future implementations may do more with this type
    while(t != null)
    {
      sb.append(t.image);
      t = t.next;
    }

    // this string can be used as-is for the translation into PL/SQL
	jjtn000.jjtSetValue(sb.toString());
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ObjectAttributeList()                     :
{/*@bgen(jjtree) ObjectAttributeList */
  ASTObjectAttributeList jjtn000 = new ASTObjectAttributeList(JJTOBJECTATTRIBUTELIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ObjectAttributeList */
  try {
/*@egen*/
  Value() ("," Value())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
 * The StringValue class stores a string literal in the 
 * node's generic value attribute.
 */

void StringValue()             :
{/*@bgen(jjtree) StringValue */
  ASTStringValue jjtn000 = new ASTStringValue(JJTSTRINGVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) StringValue */
  try {
/*@egen*/
  t = < S_CHAR_LITERAL >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    // use the generic value attribute of the node.
    jjtn000.jjtSetValue(t.image);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
 * The NumberValue class stores the string
 * representation of an integer or a real
 * number in the node's generic value attribute.
 */

void NumberValue()             :
{/*@bgen(jjtree) NumberValue */
  ASTNumberValue jjtn000 = new ASTNumberValue(JJTNUMBERVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
  StringBuffer sb = new StringBuffer();
}
{/*@bgen(jjtree) NumberValue */
  try {
/*@egen*/
  t = < S_NUMBER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    sb.append(t.image);
	jjtn000.jjtSetValue(sb.toString());
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelObjectAttributeValue() :
{}
{
  Value()
}

void MultilevelFactMeasureValue() :
{}
{
  (
    Value()
  | AggregationFunction()
  )
}

void AggregationFunction()                      :
{/*@bgen(jjtree) AggregationFunction */
  ASTAggregationFunction jjtn000 = new ASTAggregationFunction(JJTAGGREGATIONFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) AggregationFunction */
  try {
/*@egen*/
  (
    t = "SUM" |
    t = "AVG" |
    t = "MIN" |
    t = "MAX" |
    t = "SET_UNION"
  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/  
}

/**
 * This class represents the DEFAULT flag, which
 * indicates that the value that was set is a default
 * value. If a DEFAULT node is in the tree, it signifies
 * that the value that is assigned is a default value.
 * This node holds no value.
 */

void Default()          :
{/*@bgen(jjtree) Default */
  ASTDefault jjtn000 = new ASTDefault(JJTDEFAULT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Default */
  try {
/*@egen*/
  "DEFAULT"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**
 * This class represents the SHARED flag, which
 * indicates that the value that was set is a shared
 * value. If a SHARED node is in the tree, it signifies
 * that the value that is assigned is a shared value.
 * This is the default setting.
 * This node holds no value.
 */
void Shared()         :
{/*@bgen(jjtree) Shared */
  ASTShared jjtn000 = new ASTShared(JJTSHARED);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Shared */
  try {
/*@egen*/
  "SHARED"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void DimensionHierarchyID()                       :
{/*@bgen(jjtree) DimensionHierarchyID */
  ASTDimensionHierarchyID jjtn000 = new ASTDimensionHierarchyID(JJTDIMENSIONHIERARCHYID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) DimensionHierarchyID */
  try {
/*@egen*/
  t = < S_IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelObjectID()                     :
{/*@bgen(jjtree) MultilevelObjectID */
  ASTMultilevelObjectID jjtn000 = new ASTMultilevelObjectID(JJTMULTILEVELOBJECTID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultilevelObjectID */
  try {
/*@egen*/

  //( LOOKAHEAD(2) MultilevelObjectUnqualifiedIDList() | MultilevelObjectQualifiedIDList() )

  MultilevelObjectUnqualifiedID()
  (
    "IN" ("DIMENSION")?
    DimensionHierarchyID()
  )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelObjectQualifiedID()                              :
{/*@bgen(jjtree) MultilevelObjectQualifiedID */
  ASTMultilevelObjectQualifiedID jjtn000 = new ASTMultilevelObjectQualifiedID(JJTMULTILEVELOBJECTQUALIFIEDID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultilevelObjectQualifiedID */
  try {
/*@egen*/
  MultilevelObjectUnqualifiedID() "IN" ("DIMENSION")? DimensionHierarchyID()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelObjectUnqualifiedID()                                :
{/*@bgen(jjtree) MultilevelObjectUnqualifiedID */
  ASTMultilevelObjectUnqualifiedID jjtn000 = new ASTMultilevelObjectUnqualifiedID(JJTMULTILEVELOBJECTUNQUALIFIEDID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) MultilevelObjectUnqualifiedID */
  try {
/*@egen*/
  t = < S_IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);    
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelObjectIDList() :
{}
{
  ( LOOKAHEAD(2) MultilevelObjectQualifiedIDList() | MultilevelObjectUnqualifiedIDList() )
  //MultilevelObjectID() ("," MultilevelObjectID())*
}

void MultilevelObjectUnqualifiedIDList() :
{}
{
  MultilevelObjectUnqualifiedID() ("," MultilevelObjectUnqualifiedID())*
}

void MultilevelObjectQualifiedIDList() :
{}
{
  MultilevelObjectQualifiedID() ("," MultilevelObjectQualifiedID())*
}

void MultilevelObjectLevelID()                          :
{/*@bgen(jjtree) MultilevelObjectLevelID */
  ASTMultilevelObjectLevelID jjtn000 = new ASTMultilevelObjectLevelID(JJTMULTILEVELOBJECTLEVELID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) MultilevelObjectLevelID */
  try {
/*@egen*/
  t = < S_IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);    
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelObjectLevelIDList() :
{}
{
  MultilevelObjectLevelID() |
  (
    "(" MultilevelObjectLevelID()
    ("," MultilevelObjectLevelID())*
    ")"
  )
}

void MultilevelObjectAttributeID()                              :
{/*@bgen(jjtree) MultilevelObjectAttributeID */
  ASTMultilevelObjectAttributeID jjtn000 = new ASTMultilevelObjectAttributeID(JJTMULTILEVELOBJECTATTRIBUTEID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) MultilevelObjectAttributeID */
  try {
/*@egen*/
  t = < S_IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);    
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelCubeID()                   :
{/*@bgen(jjtree) MultilevelCubeID */
  ASTMultilevelCubeID jjtn000 = new ASTMultilevelCubeID(JJTMULTILEVELCUBEID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) MultilevelCubeID */
  try {
/*@egen*/
  t = < S_IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);    
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelFactID()                   :
{/*@bgen(jjtree) MultilevelFactID */
  ASTMultilevelFactID jjtn000 = new ASTMultilevelFactID(JJTMULTILEVELFACTID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultilevelFactID */
  try {
/*@egen*/
  MultilevelCubeCoordinate() "IN" ("CUBE")? MultilevelCubeID()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelFactConnectionLevelID()                                  :
{/*@bgen(jjtree) MultilevelFactConnectionLevelID */
  ASTMultilevelFactConnectionLevelID jjtn000 = new ASTMultilevelFactConnectionLevelID(JJTMULTILEVELFACTCONNECTIONLEVELID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultilevelFactConnectionLevelID */
  try {
/*@egen*/
  MultilevelObjectLevelID() ("," MultilevelObjectLevelID())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelFactMeasureID()                          :
{/*@bgen(jjtree) MultilevelFactMeasureID */
  ASTMultilevelFactMeasureID jjtn000 = new ASTMultilevelFactMeasureID(JJTMULTILEVELFACTMEASUREID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) MultilevelFactMeasureID */
  try {
/*@egen*/
  t = < S_IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);    
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MetalevelID()              :
{/*@bgen(jjtree) MetalevelID */
  ASTMetalevelID jjtn000 = new ASTMetalevelID(JJTMETALEVELID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) MetalevelID */
  try {
/*@egen*/
  t = < S_IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);    
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/**********/

void Statement() :
{}
{
  (DDLStatement() | DMLStatement() | DQLStatement() ) ";"
}
 

void Block()        :
{/*@bgen(jjtree) Block */
  ASTBlock jjtn000 = new ASTBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Block */
  try {
/*@egen*/
  /* A block has an arbitrary number of statements. */
  "BEGIN"
  (
    Statement()
  )*
  "END"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void DDLStatement() :
{}
{
  (
    CreateStatement()
  | AlterStatement()
  | DropStatement()
  )
}

void DMLStatement() :
{}
{
  UpdateStatement()
}

/********* CREATE **********/
void CreateStatement() :
{}
{
  "CREATE"
  (
    CreateDimension()
  | CreateMultilevel()
  )
}

  /***** CREATE DIMENSION *****/
void CreateDimension() :
{}
{
  "DIMENSION"
  (
    CreateDimensionHierarchy()
  )
}

void CreateDimensionHierarchy()                           :
{/*@bgen(jjtree) CreateDimensionHierarchy */
 ASTCreateDimensionHierarchy jjtn000 = new ASTCreateDimensionHierarchy(JJTCREATEDIMENSIONHIERARCHY);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) CreateDimensionHierarchy */
  try {
/*@egen*/
  "HIERARCHY" DimensionHierarchyID()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    t = getToken(0);
    jjtn000.jjtSetErrorLine(t.endLine);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void CreateMultilevelObject()                         :
{/*@bgen(jjtree) CreateMultilevelObject */
 ASTCreateMultilevelObject jjtn000 = new ASTCreateMultilevelObject(JJTCREATEMULTILEVELOBJECT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) CreateMultilevelObject */
  try {
/*@egen*/
  "OBJECT" MultilevelObjectQualifiedID()
  "AT" ("LEVEL")? MultilevelObjectLevelID()
  ( "UNDER" MultilevelObjectParents() )?
  ( MultilevelObjectLevelHierarchy() )?
  ( MultilevelObjectAttributeValueBlock() )?/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    t = getToken(0);
    jjtn000.jjtSetErrorLine(t.endLine);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelObjectParents()                          :
{/*@bgen(jjtree) MultilevelObjectParents */
  ASTMultilevelObjectParents jjtn000 = new ASTMultilevelObjectParents(JJTMULTILEVELOBJECTPARENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultilevelObjectParents */
  try {
/*@egen*/
  MultilevelObjectUnqualifiedIDList()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelObjectLevelHierarchy()                                 :
{/*@bgen(jjtree) MultilevelObjectLevelHierarchy */
  ASTMultilevelObjectLevelHierarchy jjtn000 = new ASTMultilevelObjectLevelHierarchy(JJTMULTILEVELOBJECTLEVELHIERARCHY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultilevelObjectLevelHierarchy */
  try {
/*@egen*/
  "HIERARCHY" "("
    MultilevelObjectLevelList()
  ")"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelObjectLevelList() :
{}
{
  MultilevelObjectLevelDefinition() ("," MultilevelObjectLevelDefinition())*
}

void MultilevelObjectLevelDefinition()                                  :
{/*@bgen(jjtree) MultilevelObjectLevelDefinition */
  ASTMultilevelObjectLevelDefinition jjtn000 = new ASTMultilevelObjectLevelDefinition(JJTMULTILEVELOBJECTLEVELDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultilevelObjectLevelDefinition */
  try {
/*@egen*/
  "LEVEL" MultilevelObjectLevelID()
  "CHILD" "OF" MultilevelObjectLevelParentLevels()
  ("(" MultilevelObjectLevelAttributeList() ")")?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelObjectLevelParentLevels()                                    :
{/*@bgen(jjtree) MultilevelObjectLevelParentLevels */
  ASTMultilevelObjectLevelParentLevels jjtn000 = new ASTMultilevelObjectLevelParentLevels(JJTMULTILEVELOBJECTLEVELPARENTLEVELS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultilevelObjectLevelParentLevels */
  try {
/*@egen*/
  ("NULL" | MultilevelObjectLevelIDList())/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelObjectLevelAttributeList() :
{}
{
  MultilevelObjectLevelAttribute() ("," MultilevelObjectLevelAttribute())*
}

void MultilevelObjectLevelAttribute()                                 :
{/*@bgen(jjtree) MultilevelObjectLevelAttribute */
  ASTMultilevelObjectLevelAttribute jjtn000 = new ASTMultilevelObjectLevelAttribute(JJTMULTILEVELOBJECTLEVELATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultilevelObjectLevelAttribute */
  try {
/*@egen*/
  MultilevelObjectAttributeID() DataType()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


  /***** CREATE CUBE *****/
void CreateMultilevel() :
{}
{
  "MULTILEVEL"
  (
    CreateMultilevelObject()
  | CreateMultilevelCube()
  | CreateMultilevelFact()
  )
}


void CreateMultilevelCube()                       :
{/*@bgen(jjtree) CreateMultilevelCube */
 ASTCreateMultilevelCube jjtn000 = new ASTCreateMultilevelCube(JJTCREATEMULTILEVELCUBE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) CreateMultilevelCube */
  try {
/*@egen*/
  "CUBE" MultilevelCubeID()
  "OF" "DIMENSIONS" MultilevelObjectQualifiedIDList()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    t = getToken(0);
    jjtn000.jjtSetErrorLine(t.endLine);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelCubeCoordinate()                           :
{/*@bgen(jjtree) MultilevelCubeCoordinate */
  ASTMultilevelCubeCoordinate jjtn000 = new ASTMultilevelCubeCoordinate(JJTMULTILEVELCUBECOORDINATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultilevelCubeCoordinate */
  try {
/*@egen*/
  "(" MultilevelObjectIDList() ")"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void CreateMultilevelFact()                       :
{/*@bgen(jjtree) CreateMultilevelFact */
 ASTCreateMultilevelFact jjtn000 = new ASTCreateMultilevelFact(JJTCREATEMULTILEVELFACT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) CreateMultilevelFact */
  try {
/*@egen*/
  "FACT" "BETWEEN" ("OBJECTS")? MultilevelFactID()
  (MultilevelFactConnectionLevelHierarchy())?
  (MultilevelFactMeasureValueBlock())?/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    t = getToken(0);
    jjtn000.jjtSetErrorLine(t.endLine);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelFactConnectionLevelHierarchy()                                         :
{/*@bgen(jjtree) MultilevelFactConnectionLevelHierarchy */
  ASTMultilevelFactConnectionLevelHierarchy jjtn000 = new ASTMultilevelFactConnectionLevelHierarchy(JJTMULTILEVELFACTCONNECTIONLEVELHIERARCHY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultilevelFactConnectionLevelHierarchy */
  try {
/*@egen*/
  "HIERARCHY" "("
    MultilevelFactConnectionLevelList()
  ")"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelFactConnectionLevelList() :
{}
{
  MultilevelFactConnectionLevelDefinition() ("," MultilevelFactConnectionLevelDefinition())*
}

void MultilevelFactConnectionLevelDefinition()                                          : //"<" MultilevelFactConnectionLevelID() ">"
{/*@bgen(jjtree) MultilevelFactConnectionLevelDefinition */
  ASTMultilevelFactConnectionLevelDefinition jjtn000 = new ASTMultilevelFactConnectionLevelDefinition(JJTMULTILEVELFACTCONNECTIONLEVELDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultilevelFactConnectionLevelDefinition */
  try {
/*@egen*/
  "CONNECTION" "LEVEL" "<" MultilevelFactConnectionLevelID() ">"
  ("(" MultilevelFactConnectionLevelMeasureList() ")")?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelFactConnectionLevelMeasureList() :
{}
{
  MultilevelFactConnectionLevelMeasure() ("," MultilevelFactConnectionLevelMeasure())*
}

void MultilevelFactConnectionLevelMeasure()                                       :
{/*@bgen(jjtree) MultilevelFactConnectionLevelMeasure */
  ASTMultilevelFactConnectionLevelMeasure jjtn000 = new ASTMultilevelFactConnectionLevelMeasure(JJTMULTILEVELFACTCONNECTIONLEVELMEASURE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultilevelFactConnectionLevelMeasure */
  try {
/*@egen*/
  MultilevelFactMeasureID() DataType()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/***************************/

/********* ALTER **********/

void AlterStatement() :
{}
{
  "ALTER" AlterMultilevel() //| AlterCube()
}

  /***** ALTER DIMENSION *****/
void AlterMultilevel() :
{}
{
  "MULTILEVEL"
  (
    AlterMultilevelObject()
  | AlterMultilevelFact()
  )
}

void AlterMultilevelObject()                        :
{/*@bgen(jjtree) AlterMultilevelObject */
 ASTAlterMultilevelObject jjtn000 = new ASTAlterMultilevelObject(JJTALTERMULTILEVELOBJECT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) AlterMultilevelObject */
  try {
/*@egen*/
  "OBJECT" MultilevelObjectQualifiedID()
  (
    AlterMultilevelObjectAddAttribute()
  | AlterMultilevelObjectDropAttribute()
  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    t = getToken(0);
    jjtn000.jjtSetErrorLine(t.endLine);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void AlterMultilevelObjectAddAttribute()                                    :
{/*@bgen(jjtree) AlterMultilevelObjectAddAttribute */
  ASTAlterMultilevelObjectAddAttribute jjtn000 = new ASTAlterMultilevelObjectAddAttribute(JJTALTERMULTILEVELOBJECTADDATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AlterMultilevelObjectAddAttribute */
  try {
/*@egen*/
  "ADD" ("ATTRIBUTE")? MultilevelObjectAttributeList()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void AlterMultilevelObjectDropAttribute()                                     :
{/*@bgen(jjtree) AlterMultilevelObjectDropAttribute */
  ASTAlterMultilevelObjectDropAttribute jjtn000 = new ASTAlterMultilevelObjectDropAttribute(JJTALTERMULTILEVELOBJECTDROPATTRIBUTE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AlterMultilevelObjectDropAttribute */
  try {
/*@egen*/
  "DROP" ("ATTRIBUTE")? MultilevelObjectAttributeID()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelObjectAttributeList() :
{}
{
  MultilevelObjectLevelAttribute() ("," MultilevelObjectLevelAttribute())*
  "AT" ("LEVEL")? MultilevelObjectLevelID()
}

  
  /***** ALTER CUBE *****/
void AlterCube() :
{}
{
  "MULTILEVEL" 
}

void AlterMultilevelFact()                      :
{/*@bgen(jjtree) AlterMultilevelFact */
 ASTAlterMultilevelFact jjtn000 = new ASTAlterMultilevelFact(JJTALTERMULTILEVELFACT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) AlterMultilevelFact */
  try {
/*@egen*/
  "FACT" "BETWEEN" "OBJECTS" MultilevelFactID()
  (
    AlterMultilevelFactAddMeasure()
  | AlterMultilevelFactDropMeasure()
  )+/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    t = getToken(0);
    jjtn000.jjtSetErrorLine(t.endLine);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void AlterMultilevelFactAddMeasure()                                :
{/*@bgen(jjtree) AlterMultilevelFactAddMeasure */
  ASTAlterMultilevelFactAddMeasure jjtn000 = new ASTAlterMultilevelFactAddMeasure(JJTALTERMULTILEVELFACTADDMEASURE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AlterMultilevelFactAddMeasure */
  try {
/*@egen*/
  "ADD" ("MEASURE")? MultilevelFactMeasureList()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void AlterMultilevelFactDropMeasure()                                 :
{/*@bgen(jjtree) AlterMultilevelFactDropMeasure */
  ASTAlterMultilevelFactDropMeasure jjtn000 = new ASTAlterMultilevelFactDropMeasure(JJTALTERMULTILEVELFACTDROPMEASURE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AlterMultilevelFactDropMeasure */
  try {
/*@egen*/
  "DROP" ("MEASURE")? MultilevelFactMeasureID()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelFactMeasureList() : //"<" MultilevelFactConnectionLevelID() ">"
{}
{
  MultilevelFactConnectionLevelMeasure() ("," MultilevelFactConnectionLevelMeasure())*
  "AT" ("CONNECTION" "LEVEL")? "<" MultilevelFactConnectionLevelID() ">"
}

/*************************/


/********* DROP **********/

void DropStatement() :
{}
{
  "DROP"
  (
    DropDimension()
  | DropMultilevel()
  ) 
}

  /***** DROP DIMENSION *****/

void DropDimension() :
{}
{
  "DIMENSION"
  (
    DropDimensionHierarchy()
  )
}

void DropDimensionHierarchy()                         :
{/*@bgen(jjtree) DropDimensionHierarchy */
 ASTDropDimensionHierarchy jjtn000 = new ASTDropDimensionHierarchy(JJTDROPDIMENSIONHIERARCHY);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) DropDimensionHierarchy */
  try {
/*@egen*/
  "HIERARCHY" DimensionHierarchyID()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    t = getToken(0);
    jjtn000.jjtSetErrorLine(t.endLine);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void DropMultilevelObject()                       :
{/*@bgen(jjtree) DropMultilevelObject */
 ASTDropMultilevelObject jjtn000 = new ASTDropMultilevelObject(JJTDROPMULTILEVELOBJECT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) DropMultilevelObject */
  try {
/*@egen*/
  "OBJECT" MultilevelObjectQualifiedID()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    t = getToken(0);
    jjtn000.jjtSetErrorLine(t.endLine);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


  /***** DROP CUBE *****/

void DropMultilevel() :
{}
{
  "MULTILEVEL"
  (
    DropMultilevelObject()
  | DropMultilevelCube()
  | DropMultilevelFact()
  )
}

void DropMultilevelCube()                     :
{/*@bgen(jjtree) DropMultilevelCube */
 ASTDropMultilevelCube jjtn000 = new ASTDropMultilevelCube(JJTDROPMULTILEVELCUBE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) DropMultilevelCube */
  try {
/*@egen*/
  "CUBE" MultilevelCubeID()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    t = getToken(0);
    jjtn000.jjtSetErrorLine(t.endLine);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void DropMultilevelFact()                     :
{/*@bgen(jjtree) DropMultilevelFact */
 ASTDropMultilevelFact jjtn000 = new ASTDropMultilevelFact(JJTDROPMULTILEVELFACT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) DropMultilevelFact */
  try {
/*@egen*/
  "FACT" "BETWEEN" "OBJECTS" MultilevelFactID()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    t = getToken(0);
    jjtn000.jjtSetErrorLine(t.endLine);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

/***************************/


/********* UPDATE **********/

void UpdateStatement() :
{}
{
  "UPDATE" UpdateMultilevel() 

}

void UpdateMultilevel() :
{}
{
  "MULTILEVEL"
  (
    UpdateMultilevelObject()
  | UpdateMultilevelFact()
  )
}

void UpdateMultilevelObject()                         :
{/*@bgen(jjtree) UpdateMultilevelObject */
 ASTUpdateMultilevelObject jjtn000 = new ASTUpdateMultilevelObject(JJTUPDATEMULTILEVELOBJECT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) UpdateMultilevelObject */
  try {
/*@egen*/
  "OBJECT" MultilevelObjectQualifiedID() MultilevelObjectAttributeValueBlock()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    t = getToken(0);
    jjtn000.jjtSetErrorLine(t.endLine);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelObjectAttributeValueAssignment()                                           :
{/*@bgen(jjtree) MultilevelObjectAttributeValueAssignment */
  ASTMultilevelObjectAttributeValueAssignment jjtn000 = new ASTMultilevelObjectAttributeValueAssignment(JJTMULTILEVELOBJECTATTRIBUTEVALUEASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultilevelObjectAttributeValueAssignment */
  try {
/*@egen*/
  MultilevelObjectAttributeID() ("." MetalevelID())? "="
  MultilevelObjectAttributeValue() (Default() | Shared())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void UpdateMultilevelFact()                       :
{/*@bgen(jjtree) UpdateMultilevelFact */
 ASTUpdateMultilevelFact jjtn000 = new ASTUpdateMultilevelFact(JJTUPDATEMULTILEVELFACT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) UpdateMultilevelFact */
  try {
/*@egen*/
  "FACT" "BETWEEN" "OBJECTS" MultilevelFactID() MultilevelFactMeasureValueBlock()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    t = getToken(0);
    jjtn000.jjtSetErrorLine(t.endLine);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelFactMeasureValueAssignment()                                       :
{/*@bgen(jjtree) MultilevelFactMeasureValueAssignment */
  ASTMultilevelFactMeasureValueAssignment jjtn000 = new ASTMultilevelFactMeasureValueAssignment(JJTMULTILEVELFACTMEASUREVALUEASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultilevelFactMeasureValueAssignment */
  try {
/*@egen*/
  MultilevelFactMeasureID() ("." MetalevelID())? "="
  MultilevelFactMeasureValue() (Default() | Shared())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

  /***** BULK Statements *****/

void BulkCreateMultilevelObject()                             :
{/*@bgen(jjtree) BulkCreateMultilevelObject */
  ASTBulkCreateMultilevelObject jjtn000 = new ASTBulkCreateMultilevelObject(JJTBULKCREATEMULTILEVELOBJECT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BulkCreateMultilevelObject */
  try {
/*@egen*/
  "BULK"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void BulkUpdateMultilevelObject()                             :
{/*@bgen(jjtree) BulkUpdateMultilevelObject */
  ASTBulkUpdateMultilevelObject jjtn000 = new ASTBulkUpdateMultilevelObject(JJTBULKUPDATEMULTILEVELOBJECT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BulkUpdateMultilevelObject */
  try {
/*@egen*/
  (BulkUpdateMultilevelObjectBlock())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void BulkUpdateMultilevelObjectBlock()                                  :
{/*@bgen(jjtree) BulkUpdateMultilevelObjectBlock */
  ASTBulkUpdateMultilevelObjectBlock jjtn000 = new ASTBulkUpdateMultilevelObjectBlock(JJTBULKUPDATEMULTILEVELOBJECTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BulkUpdateMultilevelObjectBlock */
  try {
/*@egen*/
  "BULK"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void BulkCreateMultilevelFact()                           :
{/*@bgen(jjtree) BulkCreateMultilevelFact */
  ASTBulkCreateMultilevelFact jjtn000 = new ASTBulkCreateMultilevelFact(JJTBULKCREATEMULTILEVELFACT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BulkCreateMultilevelFact */
  try {
/*@egen*/
  "BULK"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void BulkUpdateMultilevelFact()                           :
{/*@bgen(jjtree) BulkUpdateMultilevelFact */
  ASTBulkUpdateMultilevelFact jjtn000 = new ASTBulkUpdateMultilevelFact(JJTBULKUPDATEMULTILEVELFACT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BulkUpdateMultilevelFact */
  try {
/*@egen*/
  (BulkUpdateMultilevelFactBlock())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void BulkUpdateMultilevelFactBlock()                                :
{/*@bgen(jjtree) BulkUpdateMultilevelFactBlock */
  ASTBulkUpdateMultilevelFactBlock jjtn000 = new ASTBulkUpdateMultilevelFactBlock(JJTBULKUPDATEMULTILEVELFACTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BulkUpdateMultilevelFactBlock */
  try {
/*@egen*/
  "BULK"/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelObjectAttributeValueBlock()                                      :
{/*@bgen(jjtree) MultilevelObjectAttributeValueBlock */
  ASTMultilevelObjectAttributeValueBlock jjtn000 = new ASTMultilevelObjectAttributeValueBlock(JJTMULTILEVELOBJECTATTRIBUTEVALUEBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultilevelObjectAttributeValueBlock */
  try {
/*@egen*/
  "SET" MultilevelObjectAttributeValueAssignment() ("," MultilevelObjectAttributeValueAssignment())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultilevelFactMeasureValueBlock()                                  :
{/*@bgen(jjtree) MultilevelFactMeasureValueBlock */
  ASTMultilevelFactMeasureValueBlock jjtn000 = new ASTMultilevelFactMeasureValueBlock(JJTMULTILEVELFACTMEASUREVALUEBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultilevelFactMeasureValueBlock */
  try {
/*@egen*/
  "SET" MultilevelFactMeasureValueAssignment() ("," MultilevelFactMeasureValueAssignment())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void DQLStatement() :
{}
{
  (LOOKAHEAD(2)(ClosedMCubeQuery()) | SQLSelectStatement())
}

void ClosedMCubeQuery()                     :
{/*@bgen(jjtree) #ClosedMCubeQuery(true) */
  ASTClosedMCubeQuery jjtn000 = new ASTClosedMCubeQuery(JJTCLOSEDMCUBEQUERY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) #ClosedMCubeQuery(true) */
  try {
/*@egen*/
  "SELECT"
  "MULTILEVEL" ProjectionBlock()
  "FROM" ( DiceBlock() | CubeBlock() )
  (
    "WHERE" SliceBlock()
  )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void DiceBlock()            :
{/*@bgen(jjtree) DiceBlock */
  ASTDiceBlock jjtn000 = new ASTDiceBlock(JJTDICEBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DiceBlock */
  try {
/*@egen*/
  "DICE" "[" DiceMultilevelObjectIDList() "]" "(" InputCubeBlock() ")" (CubeAlias())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void CubeBlock()            :
{/*@bgen(jjtree) CubeBlock */
  ASTCubeBlock jjtn000 = new ASTCubeBlock(JJTCUBEBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CubeBlock */
  try {
/*@egen*/
  ( MultilevelCubeID() (CubeAlias())? ) | ( "(" ClosedMCubeQuery() ")" (CubeAlias())? )/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void DiceMultilevelObjectIDList()                             :
{/*@bgen(jjtree) DiceMultilevelObjectIDList */
  ASTDiceMultilevelObjectIDList jjtn000 = new ASTDiceMultilevelObjectIDList(JJTDICEMULTILEVELOBJECTIDLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DiceMultilevelObjectIDList */
  try {
/*@egen*/
  MultilevelObjectIDList()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void InputCubeBlock()                 :
{/*@bgen(jjtree) InputCubeBlock */
  ASTInputCubeBlock jjtn000 = new ASTInputCubeBlock(JJTINPUTCUBEBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InputCubeBlock */
  try {
/*@egen*/
  MultilevelCubeID() | ClosedMCubeQuery()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SliceBlock()             :
{/*@bgen(jjtree) SliceBlock */
  ASTSliceBlock jjtn000 = new ASTSliceBlock(JJTSLICEBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SliceBlock */
  try {
/*@egen*/
  ( SliceExpression() | SliceConversionExpression() )
  ("AND" ( SliceExpression() | SliceConversionExpression() ))*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SliceExpression()                  :
{/*@bgen(jjtree) SliceExpression */
  ASTSliceExpression jjtn000 = new ASTSliceExpression(JJTSLICEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SliceExpression */
  try {
/*@egen*/
  SliceExpressionPath() ComparisonOperator() Value()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ProjectionBlock()                  :
{/*@bgen(jjtree) ProjectionBlock */
  ASTProjectionBlock jjtn000 = new ASTProjectionBlock(JJTPROJECTIONBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ProjectionBlock */
  try {
/*@egen*/
  ( (LOOKAHEAD(2) CubeAlias()".")? MultilevelFactMeasureID()
  	("," (LOOKAHEAD(2) CubeAlias()".")? MultilevelFactMeasureID())* ) | "*"/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void CubeAlias()            :
{/*@bgen(jjtree) CubeAlias */
  ASTCubeAlias jjtn000 = new ASTCubeAlias(JJTCUBEALIAS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) CubeAlias */
  try {
/*@egen*/
  t = < S_IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);    
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SliceExpressionPath()                      :
{/*@bgen(jjtree) SliceExpressionPath */
  ASTSliceExpressionPath jjtn000 = new ASTSliceExpressionPath(JJTSLICEEXPRESSIONPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SliceExpressionPath */
  try {
/*@egen*/
  (LOOKAHEAD(2) CubeAlias()".")? DimensionHierarchyID()"."MultilevelObjectLevelID()"."MultilevelObjectAttributeID()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void RollupExpression()                   :
{/*@bgen(jjtree) RollupExpression */
  ASTRollupExpression jjtn000 = new ASTRollupExpression(JJTROLLUPEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RollupExpression */
  try {
/*@egen*/
  "ROLLUP" 
  "[" MeasureLevelPathList() "]" "(" InputCubeBlock() ")"
  ( RollupUnitConversionList() )?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MeasureLevelPathList()                       :
{/*@bgen(jjtree) MeasureLevelPathList */
  ASTMeasureLevelPathList jjtn000 = new ASTMeasureLevelPathList(JJTMEASURELEVELPATHLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MeasureLevelPathList */
  try {
/*@egen*/
  MeasureLevelPath() ("," MeasureLevelPath())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void MeasureLevelPath()                   :
{/*@bgen(jjtree) MeasureLevelPath */
  ASTMeasureLevelPath jjtn000 = new ASTMeasureLevelPath(JJTMEASURELEVELPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MeasureLevelPath */
  try {
/*@egen*/
  DimensionHierarchyID() "." MultilevelObjectLevelID()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void RollupUnitConversionList()                           :
{/*@bgen(jjtree) RollupUnitConversionList */
  ASTRollupUnitConversionList jjtn000 = new ASTRollupUnitConversionList(JJTROLLUPUNITCONVERSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RollupUnitConversionList */
   try {
/*@egen*/
   "CONVERT" ("MEASURE")? RollupUnitConversion() (LOOKAHEAD(2) "," RollupUnitConversion())*/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void RollupUnitConversion()                       :
{/*@bgen(jjtree) RollupUnitConversion */
  ASTRollupUnitConversion jjtn000 = new ASTRollupUnitConversion(JJTROLLUPUNITCONVERSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RollupUnitConversion */
   try {
/*@egen*/
   MultilevelFactMeasureIdList() "TO" MeasureUnit() "USING" MeasureUnitConversionRule()/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void MultilevelFactMeasureIdList()                              :
{/*@bgen(jjtree) MultilevelFactMeasureIdList */
  ASTMultilevelFactMeasureIdList jjtn000 = new ASTMultilevelFactMeasureIdList(JJTMULTILEVELFACTMEASUREIDLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultilevelFactMeasureIdList */
   try {
/*@egen*/
   MultilevelFactMeasureID() ("," MultilevelFactMeasureID())*/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void MeasureUnit()              :
{/*@bgen(jjtree) MeasureUnit */
  ASTMeasureUnit jjtn000 = new ASTMeasureUnit(JJTMEASUREUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MeasureUnit */
  try {
/*@egen*/
  NumberValue()
  | StringValue()
  | MultilevelObjectQualifiedID()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MeasureUnitConversionRule()                            :
{/*@bgen(jjtree) MeasureUnitConversionRule */
  ASTMeasureUnitConversionRule jjtn000 = new ASTMeasureUnitConversionRule(JJTMEASUREUNITCONVERSIONRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MeasureUnitConversionRule */
  try {
/*@egen*/
  MultilevelCubeID()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void SliceConversionExpression()                            :
{/*@bgen(jjtree) SliceConversionExpression */
  ASTSliceConversionExpression jjtn000 = new ASTSliceConversionExpression(JJTSLICECONVERSIONEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SliceConversionExpression */
  try {
/*@egen*/
  "CONVERT_TO" "(" SliceExpressionPath() "," AttributeUnit() "," AttributeUnitConversionRule() ")"
  ComparisonOperator() Value()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void AttributeUnit()                :
{/*@bgen(jjtree) AttributeUnit */
  ASTAttributeUnit jjtn000 = new ASTAttributeUnit(JJTATTRIBUTEUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AttributeUnit */
  try {
/*@egen*/
  StringValue()
  | MultilevelObjectQualifiedID()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

void AttributeUnitConversionRule()                              :
{/*@bgen(jjtree) AttributeUnitConversionRule */
  ASTAttributeUnitConversionRule jjtn000 = new ASTAttributeUnitConversionRule(JJTATTRIBUTEUNITCONVERSIONRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AttributeUnitConversionRule */
  try {
/*@egen*/
  MultilevelCubeID()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ComparisonOperator()                     :
{/*@bgen(jjtree) ComparisonOperator */
  ASTComparisonOperator jjtn000 = new ASTComparisonOperator(JJTCOMPARISONOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) ComparisonOperator */
  try {
/*@egen*/
  (
    t = "="/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);    
  } |
  t =  ">"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);    
  } |
  t =  ">="/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);    
  }|
  t =  "<"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);    
  } |
  t =  "<="/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);    
  }|
  t =  "LIKE"/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.jjtSetValue(t.image);    
  }
  )/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


/********************************************************************************/
/********************************************************************************/
/* --------------------------- SQL Grammar ------------------------------------ */
/* Adapted from http://java.net/downloads/javacc/contrib/grammars/FormsPlSql.jj */
/* and http://java.net/downloads/javacc/contrib/grammars/PlSql.jj               */
/********************************************************************************/
/********************************************************************************/

void TableColumn():
{}
{
    // user.table.column
    OracleObjectName() [ "." OracleObjectName() ["." OracleObjectName()]]
}

void OracleObjectName():
{}
{
    <S_IDENTIFIER> | <S_QUOTED_IDENTIFIER>
}

void TableReference():
{}
{
    OracleObjectName() ["." OracleObjectName()]
}

void NumOrID():
{}
{
    <S_IDENTIFIER> | (["+" | "-"] <S_NUMBER>)
}


void SQLSelectStatement()                     :
{/*@bgen(jjtree) SQLSelectStatement */
  ASTSQLSelectStatement jjtn000 = new ASTSQLSelectStatement(JJTSQLSELECTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token cur;
  StringBuffer sb = new StringBuffer();
}
{/*@bgen(jjtree) SQLSelectStatement */
    try {
/*@egen*/
    {
      cur = getToken(1);
    }
    
    SelectWithoutOrder()
    [ OrderByClause() ]
    [ ForUpdateClause() ]/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/

    {
      for(; cur != null; cur = cur.next){
        sb.append(cur.image + " ");
      }
    
      jjtn000.jjtSetValue(sb.toString());
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SelectWithoutOrder():
{}
{
    "SELECT"
    [ "ALL" | "DISTINCT" ] SelectList()
    FromClause()
    [ WhereClause() ]
    [ ConnectClause() ]
    [ GroupByClause() ]
    [ SetClause() ]
}


/* Checks for whatever follows  SELECT */
void SelectList():
{}
{
    "*" | SelectItem() ("," SelectItem())*
}

void SelectItem():
{}
{
    LOOKAHEAD(2)
    OracleObjectName()".*"  /* table.* */
|   LOOKAHEAD(4)
    OracleObjectName()"." OracleObjectName() ".*" /* schema.table.* */
|   LOOKAHEAD(2)(SQLSimpleExpression())    // Column or Expression
|   "(" SubQuery() ")"
    [<S_IDENTIFIER>] // Column Alias
}

void FromClause():
{}
{
    "FROM" FromItem() ( "," FromItem())*
}

void FromItem():
{
  Token t;
}
{
  (
    (
      TableReference() (Join())*
    ) |
    (
      "(" SubQuery() ")"
    ) |
    (
		{
		  t = getToken(1);
	    }
	    
	    RollupExpression()
	    
	    {
	      // The token that holds the ROLLUP keyword shall point
	      // to the first token after the RollupExpression production.
	      // When later the SQL string is built, only the standard
	      // SQL code is included, and the ROLLUP keyword can be
	      // replaced by a table name.
	      t.next = getToken(1);
	    }
    )
  )
  [ <S_IDENTIFIER> ]        /** Alias Name **/
}


void WhereClause():
{}
{
    "WHERE" SQLExpression()
}

void ConnectClause():
{}
{
    // The following grammar will take 2 "START WITH" expressions
    // which is not correct. But alright, because only valid statements
    // will be given.
   (["START" "WITH" SQLExpression()] "CONNECT" "BY" SQLExpression()
    ["START" "WITH" SQLExpression()])
}

void GroupByClause():
{}
{
    "GROUP" "BY" SQLExpressionList()
    ["HAVING" SQLExpression()]
}

void SetClause():
{}
{
    (("UNION" ["ALL"]) | "INTERSECT" | "MINUS")
    // LOOKAHEAD("(") because Oracle supports "(" after a UNION
    (LOOKAHEAD("(") ("(" SelectWithoutOrder() ")")
        | SelectWithoutOrder()
    )
}

void OrderByClause():
{}
{
    "ORDER" "BY" SQLSimpleExpression() ["ASC" | "DESC" ]
        ("," SQLSimpleExpression() ["ASC" | "DESC"])*
}

void ForUpdateClause():
{}
{
    "FOR" "UPDATE" "OF" TableColumn() ("," TableColumn())*
}

void SQLExpression():
{}
{
    SQLAndExpression() ("OR" SQLAndExpression())*
}

void SQLAndExpression():
{}
{
    SQLUnaryLogicalExpression() ( "AND" SQLUnaryLogicalExpression())*
}

void SQLUnaryLogicalExpression():
{}
{
    LOOKAHEAD(2) ExistsClause()
|   (["NOT"] SQLRelationalExpression())
}

void ExistsClause():
{}
{
    ["NOT"] "EXISTS" "(" SubQuery() ")"
}

void SQLRelationalExpression():
{}
{
    /* Only after looking past "(", Expression() and "," we will know that
       it is expression list */

    (LOOKAHEAD("(" SQLSimpleExpression() ",")
     "(" SQLExpressionList() ")"
|
    (["PRIOR"] SQLSimpleExpression()))

    /* Lookahead(2) is required because of NOT IN,NOT BETWEEN and NOT LIKE */
   ( LOOKAHEAD(2)(SQLRelationalOperatorExpression())
                                    |  LOOKAHEAD(2) (SQLInClause())
                                    |  LOOKAHEAD(2) (SQLBetweenClause())
                                    |  LOOKAHEAD(2) (SQLLikeClause())
                                    |  IsNullClause()
   )?
}

void IsNullClause():
{}
{
    "IS" ["NOT"] "NULL"
}

void SQLExpressionList():
{}
{
    SQLSimpleExpression() ("," SQLSimpleExpression())*
}

void SQLRelationalOperatorExpression():
{}
{

    ComparisonOperator()

    /* Only after seeing an ANY/ALL or "(" followed by a SubQuery() we can
    determine that is is a sub-query
    */
    (   LOOKAHEAD("ANY" | "ALL" | "(" "SELECT")
        (["ALL" | "ANY"] "(" SubQuery() ")")
        |
        ["PRIOR"] SQLSimpleExpression()
    )
}

void SQLInClause():
{}
{
    ["NOT"] "IN" "(" (LOOKAHEAD(2)(SQLExpressionList()) | SubQuery()) ")"
}

void SQLBetweenClause():
{}
{
    ["NOT"] "BETWEEN" SQLSimpleExpression() "AND" SQLSimpleExpression()
}

void SQLLikeClause():
{}
{
    ["NOT"] "LIKE" SQLSimpleExpression()
}

void SQLSimpleExpression():
{}
{
    SQLMultiplicativeExpression() ( ("+" | "-" | "||") SQLMultiplicativeExpression())*
}


void SQLMultiplicativeExpression():
{}
{
    SQLExpotentExpression() ( ("*" | "/") SQLExpotentExpression())*
}

void SQLExpotentExpression():
{}
{
    SQLUnaryExpression() ( "**" SQLUnaryExpression())*
}

void SQLUnaryExpression():
{}
{
    ["+" | "-"] SQLPrimaryExpression()
}


void SQLPrimaryExpression():
{}
{

    "NULL"
|    LOOKAHEAD(FunctionCall()) FunctionCall()
|    LOOKAHEAD(OuterJoinExpression()) OuterJoinExpression()
|    TableColumn()
|   < S_NUMBER >
|   < S_CHAR_LITERAL >
|   < S_BIND >
|   "(" SQLExpression() ")"
}

void FunctionCall():
{}
{
    // caters the following
    // function(args)
    // package.function(args)
    // user.package.function(args)

    // however note that "distinct/all/*" can be only used with
    // inbuilt functions but no distinction is made between inbuilt
    // function and custom functions

    OracleObjectName() [ "." OracleObjectName() ["." OracleObjectName()]]
    "(" [ ["DISTINCT" | "ALL"] (SQLArguments() | "*") ] ")"
}

void SQLArguments():
{}
{
    SQLExpressionList()
}

void Join():
{}
{
    JoinType() "JOIN" TableReference() ("ON" SQLExpression() | "USING" "(" TableColumn() ("," TableColumn())* ")")
}

void JoinType():
{}
{
    "INNER"
  | (("LEFT" | "RIGHT" | "FULL") "OUTER")
}

void OuterJoinExpression():
{}
{
    // user.table.col
    OracleObjectName() [ "." OracleObjectName() ["." OracleObjectName()]]
    "(" "+" ")"
}

void SubQuery():
{}
{
    SelectWithoutOrder()
}
